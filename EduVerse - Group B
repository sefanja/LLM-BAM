# Reference Architecture Design Brief: "EduVerse Reference Model"

## Objective

* **Title:** Design Brief: EduVerse - A Reference Business Architecture for a Modern University.
* **Objective:** Develop a reference business architecture to serve as a common language for modern, research-intensive universities. The architecture must support strategic discussions on digitalisation of education, attracting international talent, and valorisation of research.

## Core Strategic Goals

The reference architecture must enable a university to successfully pursue the following core strategic goals:

* **SG1: Student Lifecycle Management:** To provide a seamless and enriching experience for students throughout their entire academic journey. This includes the initial recruitment and application process, course enrolment, the delivery of education, examination and grading, and finally, graduation and alumni relations.
* **SG2: Research Excellence and Impact:** To create a thriving environment for groundbreaking research and ensure its value is shared with society. This includes acquiring research funding, facilitating the research process for academic staff, managing research data, and valorising research outcomes through publications and partnerships.

## Core Modeling Philosophy: The HOW-WHAT-WHY Triad

To ensure a coherent and meaningful model, you must base your entire design on the following architectural triad. This logic is the primary driver for all structural choices.

* **WHY (Value Stream):**
  This defines the **purpose** of the transformation. It represents the sequence of value-creating stages that collectively fulfill a **value commitment** made to a stakeholder, thereby achieving a strategic goal. It answers the question: "**WHY** are we doing this?"
  * **Guiding Principle (Outside-In Perspective):** When defining the value streams and their stages, you must think 'outside-in'. Start from the value promised to the stakeholder (e.g., "a recognized degree," "impactful research"). Every stage must be a necessary step to deliver on that promise.
  * **Crucial Distinction:** This is **not** a customer journey map. The stages represent the organization's internal value-creating activities required to fulfill the promise, not necessarily the stakeholder's touchpoints. For example, 'Resource Allocation Planning' or 'Logistics Scheduling' are vital value-creating stages to ensure a service can be delivered or a product can be shipped, but they are not direct touchpoints for the stakeholder.

* **WHAT (Business Object):**
 This represents the conceptual, 'real-world' entity **in a specific role** that is being transformed by the value stream. It is the subject of value creation.
  * **Crucial Principle:** A business object *is* the role. When an entity's fundamental role changes from the organization's perspective, it should be modeled as a *different* business object.
  * **Example:** 'Component Part' and 'Installed Asset' are two separate business objects. A single physical item (like a server or a machine part) transitions between these roles. As a 'Component Part' in a warehouse, it is subject to inventory management capabilities. Once installed at a client site as an 'Installed Asset', it becomes subject to maintenance and support capabilities. The value commitments and governing capabilities for these two roles are entirely different.

* **HOW (Business Capability):**
  This represents the organization's reusable **potential** to perform the transformation on the business object. It is the collection of abilities needed to execute a step in the value stream. It answers the question: "**HOW** do we have the ability to do this?"

**This logic must be the backbone of your generated model.** Each value stream stage (`WHY`) must describe the transformation of a business object (`WHAT`) realized by a primary capability (`HOW`). Your entire model should be a reflection of this interconnected triad at every level of detail.

## Task Instructions and Required Output Format

Based on the information above, generate a **fully coherent and hierarchically consistent** reference business architecture model in Markdown tables that exactly mirror the structure required for Archi's CSV import files.

### ArchiMate Mapping

* Value Streams (at `Level 0`) and Value Stream Stages (at `Level 1` and `Level 2`) must be modeled as `BusinessProcess`.
* Business Capabilities must be modeled as `BusinessFunction`.
* Business Objects must be modeled as `BusinessObject`.
* A `ServingRelationship` from a `BusinessFunction` to a `BusinessProcess` means that a business capability is manifested as a particular value stream (stage).
* An `AccessRelationship` from a `BusinessFunction` to a `BusinessObject` means that a business capability is an ability to transform that business object.
* A `ServingRelationship` between `BusinessFunction`s means that the target requires the source to reach its intended outcome (a business object transformation).
* The `CompositionRelationhip` is used for hierarchical relations.

### Crucial Architectural Rules

* **Rule 1: Hierarchical Coherence (Bottom-Up Derivation):** Transversal relations between elements at `Level 0` and `Level 1` are not created independently. They exist **only** as a direct aggregation of relationships between their children at the lowest level. For example, a `ServingRelationship` from `BF-1` to `BF-2` is only created if at least one child of `BF-1` has a relationship to a child of `BF-2`. This rule is the sole mechanism for generating parent-level relationships and prevents duplicates.

* **Rule 2: Hierarchical Realization (Process Ownership):** The principle of a single, primary realizing capability must be strictly hierarchical and mutually exclusive.
  * **At the lowest level (`Level 2`):** Each `BusinessProcess` must have **exactly one** primary incoming `ServingRelationship` from a `BusinessFunction`. This denotes the `BusinessFunction` primarily responsible for realizing the Value Stream Stage.
  * **Hierarchical Alignment Principle:** All `Level 2` children of a single `Level 1 BusinessProcess` must have their respective primary realizing `BusinessFunctions` located within the hierarchy of a **single** `Level 1 BusinessFunction`.
  * **Supporting Roles:** Other `BusinessFunction`s that assist must have a `ServingRelationship` to the primary `BusinessFunction`, either directly or indirectly via other `BusinessFunction`s.

* **Rule 3: Purposeful Capabilities (No Floating Functions):** Every `BusinessFunction` at the lowest level of decomposition (`Level 2`) must have an `AccessRelationship` to at least one `BusinessObject`. This ensures that even supporting capabilities have a clear purpose in transforming a relevant object, which may be an input for the primary capability.

* **Rule 4: Hierarchical Custodianship (Object Ownership):** Custodianship of business objects must be strictly hierarchical and mutually exclusive.
  * **At the lowest level (Level 2):** Each `BusinessObject` must have exactly one `BusinessFunction` that acts as its custodian. This is modeled with an `AccessRelationship`.
  * **Hierarchical Alignment Principle:** All `Level 2` children of a single `Level 1` `BusinessObject` must have their respective custodians within the hierarchy of a single `Level 1` `BusinessFunction`. There must be no "cross-branch" access where children of one `L1` `BusinessFunction` manage children of an `L1` `BusinessObject` that is custodially owned by another `L1` `BusinessFunction`.

### Architecture Generation Process

You will generate the architecture in a specific, sequential order to ensure both creative coherence and formal consistency.

**Step 1: Top-Down Generation of the Element Hierarchy**
First, create the full hierarchy of all elements (`BusinessFunction`, `BusinessProcess`, `BusinessObject`) without adding any transversal (non-`Composition`) relationships yet.

1. **Define Level 0:** Create the single `BusinessFunction` and the single `BusinessObject`. Then, create exactly one top-level `BusinessProcess` (Value Stream) for each of the Core Strategic Goals defined above.
2. **Define Level 1:** Decompose each `Level 0` element into its `Level 1` children.
3. **Define Level 2:** Decompose each `Level 1` element into 2-7 meaningful `Level 2` child elements. At this point, you will have a complete tree of elements in your `elements.csv` file, linked only by `CompositionRelationship`s.

**Step 2: Bottom-Up Generation of Transversal Relationships**
Now, create the `Serving` and `Access` relationships, starting **only** at the lowest level.

1. **Create Level 2 Relationships:** For each `Level 2` element, add the necessary transversal relationships, strictly adhering to `Rule 2`, `Rule 3`, and `Rule 4`. All ownership and interaction logic is defined at this level.

**Step 3: Derivation of Higher-Level Relationships**
Finally, derive the relationships for `Level 1` and `Level 0` based on the relationships you defined in Step 2.

1. **Derive Level 1 and Level 0 Relationships:** Apply `Rule 1` (Hierarchical Coherence) systematically. Create parent-level relationships *only* as an aggregation of the existing child-level relationships. This is the only way higher-level transversal relationships are created.

**Step 4: Verification and Final Output Generation**
Before generating the final tables, demonstrate that you have correctly applied **Rule 1** (Hierarchical Coherence). Do this by picking one `Level 1` `ServingRelationship` between a `BusinessFunction` and a `BusinessProcess`. Then, explicitly list the specific `Level 2` child relationships that caused you to create this parent relationship.

After providing this single, concrete example of your reasoning, proceed to generate the three complete Markdown tables as requested.

### Output Format

Please generate the output as three separate Markdown tables: one for all elements (`elements.csv`), and one for all relationships between them (`relations.csv`), and one for all properties (`properties.csv`).

#### `elements.csv` Table

This table must list every single architectural element. Generate a unique `ID` for each element.

| ID | Type | Name | Documentation |
| :--- | :--- | :--- | :--- |

**Column Definitions:**

* **ID:** A unique identifier for the element (e.g., `BP-1`, `BF-1`, `BO-1`).
* **Type:** The specific ArchiMate element type (`BusinessProcess`, `BusinessFunction`, `BusinessObject`).
* **Name:** The human-readable name of the element.
* **Documentation:** A concise description of the element's purpose.

#### `relations.csv` Table

This table must define all the relationships between the elements listed in the `elements.csv` table.

| ID | Type | Name | Documentation | Source | Target | Specialization |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |

**Column Definitions:**

* **ID:** Leave empty.
* **Type:** The specific ArchiMate relationship type. Use **only** the following:
  * **`CompositionRelationship`**: To link a parent element to its child elements.
  * **`ServingRelationship`**: To show that a `BusinessFunction` is required by another `BusinessFunction` or that it mainfests as a particular `BusinessProcess`.
  * **`AccessRelationship`**: To show that a `BusinessFunction` transforms a `BusinessObject`.
* **Name:** Leave empty.
* **Documentation:** Leave empty.
* **Source:** The `ID` of the element where the relationship starts.
* **Target:** The `ID` of the element where the relationship ends.
* **Specialization:** Leave empty.

#### `properties.csv` Table

This table adds the properties `Level` and `Code` to each element defined in the `elements.csv` table.

| ID | Key | Value |
| :--- | :--- | :--- |

**Column Definitions:**

* **ID:** The `ID` of the element used in the `elements.csv` table.
* **Key:** Per element: use `Level` for the first row, `Code` for the second.
* **Value:** For `Level` put in `0`, `1`, or `2`, based on the element's place in the hierarchy. For `Code`, put in the element's `ID`.
